{describe, it, expect, to_equal, to_throw, to_not_throw} = import '@fink/jest'

{init_parser, start_parser} = import '.'
{curr_is, curr_value, curr_loc} = import '.'
{next_is, next_is_end, next_matches, next_loc} = import '.'
{assert_curr, assert_next, assert_advance, advance} = import '.'
{expression, collect_text} = import '.'

{add_separator, add_operator, add_identifier} = import './symbols'
{add_whitespace} = import './symbols'
{symbol, other_token} = import './symbols'

{end_token} = import './tokenizer'


other = fn:
  dict:
    ...symbol other_token

    nud: fn: fn ctx:
      value = curr_value ctx
      [{type: other_token, value}, ctx]


infix = fn op:
  dict:
    ...symbol op

    led: fn lbp: fn ctx, left:
      [right, next_ctx] = expression ctx, lbp
      [{type: 'infx', op, left, right}, next_ctx]


prefix = fn op:
  dict:
    ...symbol op

    nud: fn lbp: fn ctx:
      [right, next_ctx] = expression ctx, lbp
      [{type: 'prefix', op, right}, next_ctx]


string = fn op:
  dict:
    ...symbol op
    nud: fn: fn ctx:
      [txt, next_ctx] = collect_text ctx, op
      [{type: 'string', op, value: txt.value}, next_ctx]



init_test_lang = fn ctx:
  pipe ctx:
    add_whitespace ' '
    add_whitespace '\n'

    add_separator symbol ';'

    add_identifier other()

    add_operator string `'`

    add_operator infix '='
    add_operator prefix '!'



parse = fn code:
  ctx = pipe {code, filename: 'test.fnk'}:
    init_parser
    init_test_lang
    start_parser

  expression ctx, 0


describe 'parser', fn:
  it 'parses simple expression', fn:
    [ast, ctx] = parse `foobar = !123`

    expect
      ast
      to_equal
        {
          type: 'infx'
          op: '='
          left: {
            type: other_token
            value: 'foobar'
          }
          right: {
            type: 'prefix'
            op: '!'
            right: {
              type: other_token
              value: '123'
            }
          }
        }

    expect
      next_is_end ctx
      to_equal true


  it 'parses string collecting text to end of string', fn:
    [ast, ctx] = parse `' foobar = 123 '`

    expect
      ast
      to_equal
        {
          type: 'string'
          op: `'`
          value: ' foobar = 123 '
        }

    expect
      next_is_end ctx
      to_equal true


describe 'curr token tests, values, and assertions', fn:
  it 'checks if current token value is same as expected', fn:
    [, ctx] = parse `foobar = 123`

    expect
      curr_is ctx, '123'
      to_equal true


  it 'checks if current token value', fn:
    [, ctx] = parse `foobar = 123`

    expect
      curr_value ctx
      to_equal '123'


  it 'gets current token loc', fn:
    [, ctx] = parse `foobar = 123`

    expect
      curr_loc ctx
      to_equal
        {
          start: {column: 9, line: 1, pos: 9}
          end: {column: 12, line: 1, pos: 12}
        }


  it 'handles token value assertions for current token', fn:
    [, ctx] = parse `foobar = 123`

    expect
      fn: assert_curr ctx, '123'
      to_not_throw()

    expect
      fn: assert_curr ctx, 'foobar'
      to_throw `
        test.fnk:1:9
        1| foobar = 123
                    ^

        Expected one of [ 'foobar' ] but found '123'.`


describe 'next token tests and assertions', fn:
  it 'checks if next token value is same as expected', fn:
    [, ctx] = parse `foobar = 123;`

    expect
      next_is ctx, ';'
      to_equal true


  it 'checks if next token matches', fn:
    [, ctx] = parse `foobar = 123;`

    expect
      next_matches ctx, rx/;/
      to_equal true


  it 'checks if end token matches', fn:
    [, ctx] = parse `foo;bar`

    expect
      next_matches ctx, rx/ni/
      to_equal false


  it 'checks if does not match if at end', fn:
    [, ctx] = parse `foo`

    next_ctx = advance ctx

    expect
      next_matches next_ctx, rx/foo/
      to_equal false


  it 'gets next token loc', fn:
    [, ctx] = parse `foobar = 123`

    expect
      next_loc ctx
      to_equal
        {
          start: {column: 12, line: 1, pos: 12}
          end: {column: 12, line: 1, pos: 12}
        }


  it 'handles token value assertions for next token', fn:
    [, ctx] = parse `foobar = 123`

    expect
      fn: assert_next ctx, end_token
      to_not_throw()

    expect
      fn: assert_next ctx, '123'
      to_throw `
        test.fnk:1:12
        1| foobar = 123
                       ^

        Expected one of [ '123' ] but found Symbol(end).`


describe 'advance to next token or throw', fn:

  it 'advances to the next token if next token value is as expected', fn:
    [, ctx] = parse `foobar = 123; shrub = ni`

    next_ctx = assert_advance ctx, ';'

    expect
      next_is next_ctx, 'shrub'
      to_equal true


  it 'throws when next token value is unexpected', fn:
    [, ctx] = parse `foobar = 123; shrub = ni`

    expect
      fn: assert_advance ctx, '=='
      to_throw `
        test.fnk:1:12
        1| foobar = 123; shrub = ni
                       ^

        Expected one of [ '==' ] but found ';'.`


describe 'parse exceptions', fn:
  it 'throws unexpected end of code', fn:
    expect
      fn: parse `foobar =`
      to_throw `
        test.fnk:1:8
        1| foobar =
                   ^

        Unexpected end of code.`


  it 'throws unexpected infix', fn:
    expect
      fn: parse `= 123`
      to_throw `
        test.fnk:1:0
        1| = 123
           ^

        Unexpected token '=' at start of expression.`


  it 'throws using prefix operator as infix operator', fn:
    expect
      fn: parse `foo ! ni`
      to_throw `
        test.fnk:1:4
        1| foo ! ni
               ^

        Cannot use '!' as an infix operator.`


  it 'throws using other as infix operator', fn:
    expect
      fn: parse `foo = spam ni`
      to_throw `
        test.fnk:1:11
        1| foo = spam ni
                      ^

        Cannot use 'ni' as an infix operator.`


  it 'throws collecting text when not finding expected end', fn:
    expect
      fn: parse `'foo bar`
      to_throw `
        test.fnk:1:8
        1| 'foo bar
                   ^

        Unexpected end of code.`

